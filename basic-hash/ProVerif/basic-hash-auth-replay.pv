(*
 * Protocol:	 Basic Hash
 * Modeler: 	 Nadim Kobeissi
 * Date:         April 2025
 *
 * Status: 	    Finished
 * 
 * attacker:    active
 * sessions:    unbounded ∞ 
 * agents:      unbounded ∞ 
 * compromises: None
 * primitives:  hash
 * properties:  authentication, replay attack
 * difficulty:  easy
 *

 ==============================================================================
 Expected result:

 --------------------------------------------------------------
 Verification summary:

 Query event(acceptR(xn,xh)) ==> event(startT(xn,xh)) is true.

 Query inj-event(acceptR(xn,xh)) ==> inj-event(startT(xn,xh)) is false.
 --------------------------------------------------------------

*)

(* ProVerif configuration *)
(* We set the attacker as active to indicate that it is allowed to intercept and modify values on channels. *)
set attacker = active.

(* Types *)
(* We define the types used in the protocol. *)
(* The type key is used to represent the keys of the participants. *)
(* The type nonce is used to represent nonces generated by the participants. *)
(* The type hashed is used to represent the hash values computed from keys and nonces. *)
type key.
type nonce.
type hashed.

(* Functions *)
(* We define the hash function that takes a key and a nonce as input and produces a hashed value. *)
(* The hash function is modeled as a random oracle, meaning it is assumed to be a perfect hash function. *)
(* In applied cryptography, such a hash function may be referred to as an HMAC (a Hash-based Message Authentication Code), and this is what we intend to use it as in this example anyway. *)
fun hash(key, nonce):hashed.

(* Events *)
(* We define events to represent the acceptance of a message and the start of a session. *)
(* The event acceptR is triggered when a participant accepts a message. *)
(* The event startT is triggered when a session starts. *)
event acceptR(nonce,hashed).
event startT(nonce,hashed).

(* Queries *)
(* We define queries to check the capabilities of the attacker. *)
(* Essentially, this query mandates that if a session is accepted by the receiver with a certain nonce and hash, *)
(* then the session must have started with the same nonce and hash. *)
query xn: nonce, xh:hashed; event(acceptR(xn,xh)) ==> event(startT(xn,xh)).

(* The injective variant of the above query allows us to capture replay attacks. *)
query xn: nonce, xh:hashed; inj-event(acceptR(xn,xh)) ==> inj-event(startT(xn,xh)).

(* Channels and Processes *)
(* We define a channel pub to represent the public channel used for communication between participants. *)
(* The keys table is used to store the keys of the participants. *)
channel pub.
table keys(key).

(* The processT function represents the sender's process, while the processR function represents the receiver's process. *)
let processT(kT:key) =
	new n: nonce; (* Generate a fresh nonce, unique to each process execution. *)
	event startT(n, hash(kT, n)); (* Trigger the event signaling that a session has been started using the nonce n, and the hash of n under the secret key kT. *)
	out(pub, (n, hash(kT, n))). (* Output n and hash(kT, n) over the public channel, where they can be seen and manipulated by the attacker. *)

let processR(kR:key) =
	in(pub, (m1:nonce, m2:hashed)); (* The recipient receives as input a nonce and hash. *)
	if m2 = hash(kR,m1) then event acceptR(m1,m2). (* The recipient will only trigger the event acceptR if the received hash value is a correct HMAC for m1, with key kR. *)

(* The scenario we are setting up here is basically the following: *)
(* 1. The sender generates a nonce and computes the hash using their secret key. *)
(* 2. The sender sends the nonce and hash over the public channel, and then stores their secret key in a secrets table, not accessible to the attacker. *)
(* 3. The receiver pulls that key from the secrets table, listens on the public channel, receives the nonce and hash, and checks if they match with the hash that they calculate with the table-retrieved key. *)
(* 4. If they match, the receiver accepts the message. *)
(* We run the above interaction an unbounded number of sessions, and check to see if our query, defined above, holds. *)
process
	!(
		!(new kT: key; insert keys(kT); processT(kT))
		|
		!(get keys(xkT) in processR(xkT))
	)

(*
Fun experiments:

- Check what happens if we add `out(pub, kT)` to the sender process. The attacker will have access to the key, since it's sent on the public channel.
- Check what happens if we add `in(pub, kR:key)` to the receiver process. The attacker will be able to feed the receiver a key of their choice, and the receiver will accept any message that matches the hash with that key.
*)